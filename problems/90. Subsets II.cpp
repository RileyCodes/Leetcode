class Solution {
public:
    
    /*
    这道题中，数组中会有重复数字，但是可以发现对于[1,2,2]，[2,2]这种子集是可以接受的
    而[2]则只能有一个。因此，组合还是全部组合，但是需要去除完全一样的子集。
    根据子集 I的题目我们可以确定这道题的复杂度很高，因此做一个排序对复杂度也没有影响。
    
    现在只考虑输入被排序过的情况。
    
    观察 12224这个数据：
    001 010 011 100 101 110 111 
    1000 -> 2 忽略
    1001 -> 24忽略 因为011已经是24了
    1010 -> 22 忽略 因为110已经是22了
    1011-> 224 忽略 因为 111已经是224了
    1100 -> 22  忽略
    1101 -> 224 忽略
    1110 -> 222 不忽略
    1111 -> 2224 不忽略
    10000 -> 1 不忽略
    
    */
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for(int i = 0; i < (1 << nums.size()); ++i)
            // 确保i 小于 nums的组合数量（比如说 nums.size() == 4，那么 1 << 4就是10000，走到1111算完。
        {
            vector<int> ans;
            //每次组合变化以后，遍历每一位二进制，添加新的组合
            bool ignore = false;
            for(int j = 0; j < nums.size(); ++j)
            {
                //j = 0的时候， i & (1 << j)意味着，只有最右边第一位比特是1的时候才为真
                //j = 1的时候， i & (1 << j)意味着 由于 1 << 1 = 10，只有最右边第二位比特是1的时候才为真
                //这样我们可以检查每一位数组是否应该纳入到组合中。
                //但是这道题的没这么简单！ 我们需要排除重复组合。
                if(i & (1 << j))//这里需要注意，虽然我们的循环是从比特最右边到最左边检查的，但是 j 是从0到nums.size()，数值是从最左边到最右边处理的
                {
                    ans.emplace_back(nums[j]);    
                    //判定重复组合的条件： 
                    //1.当前在处理的不是第一位 j > 0
                    //2.当前处理的这一位数字和上一位相同 nums[i] == nums[i - 1]
                    //3.把i向右移动 j - 1 位以后，最右边第一位是0。 i >> (j - 1) & 1 == 0
                    if(j > 0 && nums[j] == nums[j - 1] && (i >> (j - 1) & 1) == 0)
                    {
                        ignore = true;
                    }
                }
            }
            if(!ignore)
                result.emplace_back(ans);
        }
        
        return result;
    }
};