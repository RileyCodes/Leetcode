class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        /*我们首先创建一个数组d，这个数组代表子序列长度 i 下，可以找到的最小的结尾元素的值
        比如说3,5,4，那么d[1]是3，d[2]是4，因为长度为1的时候，子序列最小的右值就是3，而长度为2的时候，最小的右值是4
        
        具体策略是设置一个长度l=1，如果我们遇到比d[0]更大的，那么长度增加，并且给d[1]设置为这个元素的值
        如果遇到小的，那么我们直接替换d[0]
        
        对于后面的d[i]，也采取这种策略。 如果遇到大的，那么这个大的等于d[i]，如果遇到小于等于的，设这个元素的值是nums[i]
        我们要找d[i] < nums[i] < d[i + 1]，然后替换d[i + 1]为nums[i]
        其中nums[i] < d[i + 1]确保了我们在使用更小的数字替换更大的数字
        d[i] < nums[i]则确保了升序不被破坏。
        
        举个例子，如果是1,3,2,4
        那么我们会有
        d[0] = 1
        d[1] = 2
        d[3] = 4
        
        如果是1,5,6,7,2,4
        那么一开始是：
        d[0] = 1
        d[1] = 5
        d[2] = 6
        d[4] = 7
        这时候发现了2
        我们发现因为1 < 2 < 5，所以d[1] = 2
        发现了4
        因为2 < 4 < 6，所以d[2] = 4
        d = [1,2,4,7] 
        这并不是一个正确的升序序列，但是这并不影响我们得到的答案，因为1,5,6,7的长度也是4。
        
        再看看如果是1,6,7,2,4,5,6,7
        一开始是d = [1,6,7]
        然后变成[1,2,7]
        然后变成[1,2,4]
        然后变成[1,2,4,5,6,7]
        正确！

        */
        
        int d[nums.size() + 1];
        d[1] = nums[0];
        
        int l = 1;//l代表当前的序列长度
        for(int i = 1; i < nums.size(); ++i)
        {
            if(nums[i] > d[l])//如果当前选中的数比上一位最小的数更大，那么我们可以增加子序列的长度
            {
                ++l;
                d[l] = nums[i];
            }
            else
            {
                //如果当前选中的数等于或者小于上一位最小的数，这意味着我们可能发现了一个可以让子序列最后一位变的更小的数
                /*n^2方案
                for(int j = 1; j <= nums.size(); ++j)
                {
                    if(d[j] > nums[i])
                    {
                        if(j == 1 || d[j - 1] < nums[i])
                        {
                            d[j] = nums[i];
                        }
                    }
                }
                */
                
                //nlog(n)方案：利用数组d的单调性进行二分查找。
                int lP = 1, rP = l + 1;
                while(lP <= rP)
                {
                    int mid = (lP + rP) / 2;
                    if(d[mid] > nums[i] &&  (mid == 1 ||  d[mid - 1] < nums[i]))
                    {
                        //如果d[mid] 大于 nums[i]，并且mid是最左边的数或者mid - 1比nums[i]小，那么我们可以替换数字。
                        d[mid] = nums[i];
                        break;
                    }
                    //否则的话，如果d[mid] > nums[i]，但是前面的条件没构成
                    //这意味着我们可能遇到了nums[i] = 5，但是遇到了[3,6,6,6]这种情况，还需要继续往左移动寻找更小的数。
                    else if(d[mid] > nums[i])
                    {
                        rP = mid - 1;
                    }
                    else//这说明我们的nums[i] = 5，但是mid指向了一个更小的数，比如说[2,3,6,6,6]中的3，我们需要向右搜索
                    {
                        lP = mid + 1;    
                    }
                }
            }
        }
        
        return l;
    }
};
