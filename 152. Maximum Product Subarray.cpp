class Solution {
public:
    
    /*
    这道题要求给出一个数组，我们找出连续的子数组，使其乘积最大
    动态规划： 最后一步 -> 更小规模子问题 -> 状态转移方程 -> 初值/边界条件
    
    最后一步：
    首先考虑到，找到了最大值的时候dp算法并不能确定这个值是最大值（我们不可能在发现最大值以后就意识到这是最大值）
    所以最后一步不会是找到最大值的哪一步
    
    最后一步应该是完成了对最后一个元素 i 的检查，获得了 f[i] * [m, i -1] 可以计算出的最大乘积。
    
    其中m 是从0到 i -1的任何一个整数，我们需要找出哪一段连乘出来最大或最小（取决于元素i是正数还是负数）
    
    为什么是最大或最小？ 如果 元素 i 的值 > 0，那么我们需要最大比如说 4 * 3 = 12
    如果元素 i 的值 = 0，我们无所谓另外的乘积是什么，都是0
    如果元素 i 的值 < 0，比如说-1,那么 越大的乘积会带来更小的结果，比如说-1 * 100 = -100，而越小的数会带来更大的结果
    比如说-1 * 50 = -50 , -1 * 1 = -1,  -1 * 0 = 0, -1 * -1 = 1, -1 * -2 = 2.
    
    
    更小规模子问题：
    
    [m, i - 2] * f[i - 1]能产生的最大/最小的积是多少？ 其中 m >= 0 && m <= i - 2
    
    状态转移方程：
    
    f_max[i] = nums[i] > 0 ? nums[i] * f_max[i - 1] : nums[i] * f_min[i - 1]
    f_min[i] = nums[i] > 0 ? nums[i] * f_min[i - 1] : nums[i] * f_max[i - 1]

    
    初值
    f_max[0] = nums[0];
    f_min[0] = nums[0];
    
    实现以后发现我们的状态转移方程没油考虑0！
    
    实际上nums[i] * f_max[i - 1]  在一些情况下会小于nums[i]本身
    比如说你有[0,2],那么 0 * 2 还不如只要2本身
    
    又比如说[-2,0,-1]，-2 * 0 = 0，0 * -1 = 0，我们最大的就是0本身。
    
    所以状态转移方程需要分别比较最大最小值是数值本身，还是乘以前面的数组
    
    如果我们只要了本身，比如说[1,0,2,3]，那么f[2] = 2，而f[3]就会是2 * 3而不再是1 * 0  * 2 * 3了；（因为我们丢弃了前面的状态）。
    
    问题解决。
    
    f_max[i] = max(nums[i] > 0 ? nums[i] * f_max[i - 1] : nums[i] * f_min[i - 1],nums[i]);
    f_min[i] = min(nums[i] > 0 ? nums[i] * f_min[i - 1] : nums[i] * f_max[i - 1],nums[i]);    

    */
    int maxProduct(vector<int>& nums) {
        int f_max[nums.size()];
        int f_min[nums.size()];
        int m = nums[0];
        f_max[0] = nums[0];
        f_min[0] = nums[0];
        
        for(int i = 1; i < nums.size(); ++i)
        {
            f_max[i] = max(nums[i] > 0 ? nums[i] * f_max[i - 1] : nums[i] * f_min[i - 1],nums[i]);
            f_min[i] = min(nums[i] > 0 ? nums[i] * f_min[i - 1] : nums[i] * f_max[i - 1],nums[i]);
            m = max(f_max[i],m);   
        }
        return m;
    }
};