class Solution {
public:
    
    /*
    这道题给出一个唯一数字的数组，要我们找到所有的子集
    比如说[1,2,3]的子集就有[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]
    
    可以想到用num.size()个滑动窗口来做，每个窗口的宽度分别是从0到nums.size() - 1
    如：
    [],[1][2][3],[1,2][2,3],[1,2,3]
    
    但是很快会发现这并不能找到所有的组合，因为这道题并没有要求数组必须是连续的！
    比如说[1,3]这个组合就被漏掉了。
    
    换一个思路实现：用二进制模拟，0代表忽略，1代表使用
    会发现 000 001 010 011 100 101 110 111
    对于[1,2,3] 这意味着[],[3],[2],[2,3],[1],[3,1],[1,2],[3,2,1]。
    问题解决！
    然而，用三个bool来代表一个二进制计数器是否太低效了？我们能不能用一个十进制int来实现这个需求呢？
    0 = 000 1 = 001 2 = 010 3 = 011 4 = 100 5 = 101 6 = 110 7 = 111
    回顾一下32位int的本质是什么？ 1001 = 2^3 + 2^0 = 9 因为第[3]位和第[0]位的二进制是1。
    所以，要将9还原为1001，我们需要知道是由哪些2^x_1+2^x_2+..+2^x_n构成的。
    
    */
    vector<vector<int>> subsets(vector<int>& nums) {
        //nums有几位，我们的二进制计数器就有几位，nums.size() == 3就意味着是从000到111。
        vector<vector<int>> result;
        
        
        //我们可以利用(1 << nums.size()) 来得出我们的组合数量。比如说 nums.size() == 3 那么 1 << 3就是二进制的1000
        // i < 1000意味着i最多走到二进制的 111，因为111 + 1 = 1000
        //这个整数 i就是从 000 001 010..一直到111.
        for(int i = 0; i < (1 << nums.size()); ++i)
        {
            vector<int> ans;
            //处理每一位数字
            // i & (1 << j) 可以用来判定i的第几位bit是否为1，如 1 << 2 是 100，这时候除了这第三位是1的，其他都会被and为零。
            //比如说 11000 & 100就会是0，因为第三位不是1
            //因此我们这里这个循环一个个判断数组第几位是1，是1就加进答案数组，否则不加。            
            for(int j = 0; j < nums.size(); ++j)
            {   
                if(i & (1 << j))
                {
                    ans.emplace_back(nums[j]);
                }
            }
            result.emplace_back(ans);
        }
        
        return result;
    }
};