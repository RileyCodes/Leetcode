class Solution {
public:
    /*
    这道题要求给出一个数组nums和一个整数k，我们要找出数组里面所有乘积 < k的连续子数组的组合数量
    比如说nums = [10,5,2,6], k = 100 ，输出是8，因为子数组可以是 [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
    这里面可以注意到其中没包括[10,2]这种组合，因为这个组合不连续。
    
    考虑到我们有4个数[a,b,c,d]
    如果我们判断发现[a][a,b][a,b,c][a,b,c,d]都小于 k 此时我们并不需要判断其他子组合，如[b,c]或者[b,c,d]
    这是因为我们的数字都 >= 1 且 乘法结合律 a * b = b = a，且 如果a*b*c*d < k那么 b*c*d或者d*c之类的都必然 < k。
    因此，我们只需要找出规律，知道[a,b,c,d]下所有有效组合数量即可，不需要去判断每一个组合是否 < k。
    发现[a] 的时候 组合 + 1
    发现[a,b] 的时候 组合 + 2  我们有[b]和[a,b]
    发现[a,b,c] 的时候，组合 + 3  我们有[c],[b,c],[a,b,c]
    发现[a,b,c,d] 的时候，我们有[d][c,d][b,c,d][a,b,c,d] 组合 + 4
    
    但是事情并没有这么简单，比如说a * b * c * d  > k的情况下，是否意味着我们必须从d往后找更多的组合？
    答案是不是的
    因为b * c * d < a * b * c *d  因此这时候收缩左指针可能会发现更多的组合。
    
    10 5 2 6
    发现[10], + 1
    发现[10,5],[5] + 2
    发现[10,5,2] 超过了，收缩左侧。
    [5 2] 小于 100， + 2
    [5 2 6] 小于 100， + 3
    右侧结束。
    1 + 2 + 2 + 3 = 8
    
    
    */
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
 
        int mul = 1;//乘法计数器
        int count = 0;//组合计数器
        int lP = 0;
        for(int rP = 0; rP < nums.size(); ++rP)
        {
            mul *= nums[rP]; 
            
            while(lP <= rP && mul >= k)//超出的情况下，收缩左侧，直到左右指向同一个数
            {
                mul /= nums[lP];
                ++lP;                      
            }
            
            if(mul < k)//向右的指针会一直走，但是只有乘数没超过的情况下才会计算发现的组合数量。
            {
                count += (rP - lP + 1);          
            } 
        }
        return count;
    }
};