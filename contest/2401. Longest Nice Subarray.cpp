class Solution {
public:
    /*
    这道题考虑使用滑动窗口。
    首先需要考虑的是，如果要线性复杂读，那么是否会发生i - 1 & i - 2 == 0且 i & i - 1 == 0 但是 i & i - 2 != 0的情况，
    
    带入具体数值看看
    i     = 1010
    i - 1 = 0101
    i - 2若要满足i - 1 & i - 2 == 0，那么只有第一位和第三位可以是1
    如 i - 2 = 1010
    此时 1010 & 0101 = 0
    但是 i 也是1010！ 1010 & 1010 > 0。
    
    由此可见，仅仅确定i和 i - 1的与运算为0是不够的。而且即使增加对i - 2的检查也没有用，如：
    0010 1000 0001 0010
    
    0001 & 0010 == 0
    1000 & 0001 == 0
    1000 & 0010 == 0
    但是
    0010 & 0010 != 0 i和 i - 3又出问题了。
    
    怀疑这道题时间复杂度是n^2，但是发现约束中 1 <= nums.length <= 10^5这个数量级用平方级别算法不行……
    
    重新思考与运算：如果第一位是1，那么我们后续的都不能有第一位是1
    所以0001 之后，我们最多最多只能遇到1110
    如果遇到了0010，在这之后我们只能遇到1100
    到最后，除了0000都不行。
    
    再看看0010 1000 0001 0010
    
    首先当0010 & 1000 == 0000
    我们做0010 | 1000 == 1010
    1010 & 0001 == 0000
    得到1011,1011 & 0010 = 0010，非零。
    通过这个办法就可以解决问题，把所有检查过的部分用与运算积累起来。
    
    因为滑动窗口只会在 & 运算为0的情况下进入，因此当前维护的变量中，每一位都绝对来自唯一一个元素
    比如说1010 只会来自于 0010 | 1000，不会来自于0010 | 1010，因为0010 & 1010 !=0
    
    因此，我们可以在发现 & 运算不为0，需要缩短左侧滑动窗口的时候，利用 XOR 运算取消已经离开的元素的影响。
    
    如1010 ^ 0010 = 1000，取消了 0010的影响。


    总结一下： 通过这道题我们学到了即使是i - 1 & i == 0 且 i - 1 & i - 2 == 0，也可能出现i & i - 2 != 0。
    解决办法是使用基于与运算的mask来收集所有的1，任何位上只要历史上出现过1，就不能再出现1，这样就可以确保整个子串互相 & 出来都是0。
    
    滑动窗口在收集了一个元素的时候，对这个元素的1做 | 运算收集到mask上
    在离开一个元素的时候，做 ^ 运算从mask上把1扣下来丢弃。
    
    */
    int longestNiceSubarray(vector<int>& nums) {
        if(nums.size() <= 1)
            return 1;
        
        int lP = 0;
        int rP = 1;
        int maxWidth = 0;
        int mask = nums[0];
        while(rP < nums.size())//没到头就一直算
        {
            int width = rP - lP;
            
            if((mask & nums[rP]) != 0)//如果新出现的不合法，那么就收缩左侧
            {
                if(lP < rP)
                {
                    mask = mask ^ nums[lP];
                    ++lP;
                }
                else
                {
                    //如果lP已经等于rP，此时窗口宽度为0， nums[lP] & nums[rP]) != 0 仅仅是因为自己 & 自己导致的。
                    //这种情况，直接重置mask
                    mask = nums[rP];
                    ++rP;
                }
                    
            }
            else
            {
                //如果合法，那么判断比较最大宽度，把新加入的纳入mask中
                maxWidth = max(width,maxWidth);
                mask = mask | nums[rP];
                ++rP;
            }
        }
        return maxWidth + 1;//左边在1，右边在3，那么 3 - 1 = 2,但是1 2 3其实是3个，所以我们需要 + 1。
    }
};